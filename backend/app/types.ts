import { TrackArtwork, User, ProfilePicture, CoverPhoto, Playlist, PlaylistAddedTimestamp, PlaylistArtwork, Access } from "@audius/sdk";
import { ChatOpenAI, ChatOpenAICallOptions } from "@langchain/openai";

export type ComplexityLevel = 'simple' | 'moderate' | 'complex' | string;
export type AudiusData = TrackData | UserData | PlaylistData | PopularTrackData | NoMatchData | null;

export interface QueryClassification {
  type: string;
  isEntityQuery: boolean;
  entityType: 'user' | 'track' | 'playlist' | null;
  entity: string | null;
  complexity: ComplexityLevel;
} 

export interface DatasetSchema {
  id: string;
  category_name: string;
  tool_name: string;
  api_name: string;
  api_description: string;
  required_parameters: DatasetParameters[];
  optional_parameters: DatasetParameters[];
  method: string;
  template_response?: Record<string, any>;
  api_url: string;
  parameters?: Record<string, any>;
  default_parameters?: { [key: string]: any };
}

export interface DatasetParameters {
  name: string;
  type: string;
  description: string;
  default: string;
}

export interface GraphState {
  llm: ChatOpenAI<ChatOpenAICallOptions>;
  query: string;
  queryType: QueryType | string;
  categories: string[];
  apis: DatasetSchema[];
  bestApi: DatasetSchema | null;
  secondaryApi?: DatasetSchema | null;
  params: {
    apiUrl?: string;
    timeframe?: string;
    limit?: number;
    track?: string;
    user?: string;
    artist?: string;
    // Add any other parameters you might need
  };
  response: any;
  secondaryResponse?: any;  
  error: boolean; // Changed from string | null to boolean
  formattedResponse?: string;
  message: string | null;
  isEntityQuery?: boolean;
  entityName?: string | null; // Added to store the entity's name
  entity: Entity | null; 
  parameters?: { [key: string]: any }; 
  complexity: ComplexityLevel | string;
  multiStepHandled?: boolean;
  initialState?: GraphState;
  entityType: 'user' | 'playlist' | 'track' | null; // Updated definition
}

export type QueryType =
  | 'trending_tracks'
  | 'search_tracks'
  | 'search_users'
  | 'search_playlists'
  | 'search_genres'
  | 'genre_info'
  | string;

export type TrackData = {
  id: string;
  type: 'track';
  title: string;
  artwork: TrackArtwork;  
  description: string | null;
  genre: string;
  mood: string | null;
  releaseDate: string | null;
  remixOf: TrackData | null;
  repostCount: number;
  favoriteCount: number;
  commentCount: number;
  tags: string[] | null;
  user: User;
  duration: number;
  isDownloadable: boolean;
  playCount: number;
  permalink: string;
  isStreamable: boolean;
};

export type UserData = {
  id: string;
  type: 'user';
  name: string;
  handle: string;
  bio: string | null;
  followerCount: number;
  followeeCount: number;
  trackCount: number;
  playlistCount: number;
  albumCount: number;
  isVerified: boolean;
  profilePicture: ProfilePicture;
  coverPhoto: CoverPhoto;
  twitterHandle: string | null;
  instagramHandle: string | null;
  tiktokHandle: string | null;
  website: string | null;
  location: string | null;
  isDeactivated: boolean;
  isAvailable: boolean;
  supporterCount: number;
  supportingCount: number;
  totalAudioBalance: number;
};

export interface PlaylistData {
  id: string;
  playlistName: string;
  description?: string;
  isAlbum: boolean;
  trackCount: number;
  totalPlayCount: number;
  repostCount: number;
  favoriteCount: number;
  user: User;
  playlistContents: Array<PlaylistAddedTimestamp>;
  artwork?: PlaylistArtwork;
  permalink: string;
  isImageAutogenerated: boolean;
  access: Access;
  ddexApp?: string;
  upc?: string;
  tracks: TrackData[];
}
  
export interface PopularTrackData {
    type: 'popularTrack';
    data: {
      rank: number;
      title: string;
      artist: string;
      playCount: number;
      duration: number;
      genre: string;
      mood?: string;
      releaseDate?: string;
  };
}
  
export interface NoMatchData {
    type: 'noMatch';
    data: {
      searchedTrack: string;
      searchedArtist: string;
    availableTracks: { title: string; artist: string; playCount: number }[];
  };
}

/**
 * Type guard to check if an object is of type UserData.
 * @param entity - The entity to check.
 * @returns True if entity is UserData, else false.
 */
export function isUserData(entity: any): entity is UserData {
  return entity && typeof entity === 'object' && 'name' in entity;
}

/**
 * Type guard to check if an object is of type TrackData.
 * @param entity - The entity to check.
 * @returns True if entity is TrackData, else false.
 */
export function isTrackData(entity: any): entity is TrackData {
  return entity && typeof entity === 'object' && 'title' in entity;
}

/**
 * Type guard to check if an object is of type PlaylistData.
 * @param entity - The entity to check.
 * @returns True if entity is PlaylistData, else false.
 */
export function isPlaylistData(entity: any): entity is PlaylistData {
  return entity && typeof entity === 'object' && 'title' in entity;
}

// Define NodeNames as a constant array with 'as const'
export type NodeNames =
  | "classify_query"
  | "extract_category"
  | "create_fetch_request"
  | "process_api_response"
  | "verify_params"
  | "processEntityQueries"
  | "get_apis"
  | "extract_parameters"
  | "extract_high_level_categories"
  | "handle_search_tracks"
  | "handle_trending_tracks"
  | "handle_search_playlists"
  | "handle_search_users"
  | "handle_search_genres"
  | "handle_entity_query"
  | "handle_playlist_info"
  | "handle_multi_step_query"
  | "log_final_result"
  | "START"
  | "END";

// Update the ApiResponse interface to use 'data' consistently
export interface ApiResponse<T> {
  data: T;
}

// Update other interfaces as needed
export interface WebSearchResult {
  title: string;
  content: string;
  // Add other relevant properties if needed
}

/**
 * Electronic subgenres are grouped under the parent genre "Electronic"
 * This gives context to the LLM that "Trance" and "Jungle" are their own genres, but both
 * are part of the "Electronic" genre overall.
 */
export const GroupedGenres = {
  ALL: "All Genres",
  ROCK: "Rock",
  METAL: "Metal",
  ALTERNATIVE: "Alternative",
  HIP_HOP_RAP: "Hip-Hop/Rap",
  EXPERIMENTAL: "Experimental",
  PUNK: "Punk",
  FOLK: "Folk",
  POP: "Pop",
  AMBIENT: "Ambient",
  SOUNDTRACK: "Soundtrack",
  WORLD: "World",
  JAZZ: "Jazz",
  ACOUSTIC: "Acoustic",
  FUNK: "Funk",
  R_AND_B_SOUL: "R&B/Soul",
  DEVOTIONAL: "Devotional",
  CLASSICAL: "Classical",
  REGGAE: "Reggae",
  PODCASTS: "Podcasts",
  COUNTRY: "Country",
  SPOKEN_WORK: "Spoken Word",
  COMEDY: "Comedy",
  BLUES: "Blues",
  KIDS: "Kids",
  AUDIOBOOKS: "Audiobooks",
  LATIN: "Latin",
  LOFI: "Lo-Fi",
  HYPERPOP: "Hyperpop",
  DANCEHALL: "Dancehall",
  ELECTRONIC: {
    ELECTRONIC: "Electronic",
    TECHNO: "Techno",
    TRAP: "Trap",
    HOUSE: "House",
    TECH_HOUSE: "Tech House",
    DEEP_HOUSE: "Deep House",
    DISCO: "Disco",
    ELECTRO: "Electro",
    JUNGLE: "Jungle",
    PROGRESSIVE_HOUSE: "Progressive House",
    HARDSTYLE: "Hardstyle",
    GLITCH_HOP: "Glitch Hop",
    TRANCE: "Trance",
    FUTURE_BASS: "Future Bass",
    FUTURE_HOUSE: "Future House",
    TROPICAL_HOUSE: "Tropical House",
    DOWNTEMPO: "Downtempo",
    DRUM_AND_BASS: "Drum & Bass",
    DUBSTEP: "Dubstep",
    JERSEY_CLUB: "Jersey Club",
    VAPORWAVE: "Vaporwave",
    MOOMBAHTON: "Moombahton",
  },
} as const;

interface BaseEntity {
  id: string;
  entityType: 'track' | 'user' | 'playlist';
  name: string; // Common field for all entity types
}

export interface TrackEntity extends BaseEntity {
  entityType: 'track';
  title: string; // Specific to tracks
  user: {
    name: string;
    handle: string;
  };
  play_count: number;
}

export interface UserEntity extends BaseEntity {
  entityType: 'user';
  handle: string; // Specific to users
  follower_count: number;
}

export interface PlaylistEntity extends BaseEntity {
  entityType: 'playlist';
  tracks: TrackEntity[];
}

export type Entity = TrackEntity | UserEntity | PlaylistEntity;

// When setting a track entity
export const setTrackEntity = (trackData: TrackData): Entity => ({
  id: trackData.id,
  entityType: 'track',
  name: trackData.title, // Use title as the name for tracks
  title: trackData.title,
  user: trackData.user,
  play_count: trackData.playCount
});

// When setting a user entity
export const setUserEntity = (userData: UserData): Entity => ({
  id: userData.id,
  entityType: 'user',
  name: userData.handle, // Use handle as the name for users
  handle: userData.handle,
  follower_count: userData.followerCount
});

// When setting a playlist entity
export const setPlaylistEntity = (playlistData: PlaylistData): Entity => ({
  id: playlistData.id,
  entityType: 'playlist',
  name: playlistData.playlistName,
  tracks: playlistData.tracks.map(setTrackEntity) as TrackEntity[]
});
